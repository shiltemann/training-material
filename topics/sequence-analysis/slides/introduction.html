---
layout: introduction_slides
logo: "GTN"
class: enlarge120

title: "Introduction to Sequence Analysis"
type: "introduction"
contributors:
  - hexylena
  - shiltemann

---

# Example NGS pipeline

![High level view of a typical NGS workflow](../images/pipeline.png)

A high level view of a typical NGS bioinformatics workflow

???
- Mapping step occurs if a reference genome is available for the organism of interest
  - else: de-novo assembly
- Variant calling step is just an example, after mapping can do many steps
  - Structural Variants / Fusion genes
  - Differential Gene expression
  - Alternative Splicing
  - ..

---

# Sequencing

![Sequencing](../images/pipeline-sequence.png)

---

## Sequencing: How it works

In **general**

1. A DNA sample is prepared
2. This is fragmented into lots of tiny fragments
3. These have barcodes, adapters, indexes, and/or primers ligated to their ends
4. Flourescently labelled Nucleotides are run across the DNA fragments, binding one at a time
5. The instrument reads the flourescent signal
6. "Base calling" happens, the flourescent signals are converted into A, C, T, and Gs and quality scores.

---

## Sequencing: Technologies and Platforms

---

### Single-end Sequencing

- Individual fragments of DNA are sequenced
- Each read is totally independent
- 30-200 bases usually

---

## Paired-end Sequencing

- **Sequencing:** Cut longer (500-600 base) fragments of DNA, sequence only the ends

  .center[.image-90[![Paired-end reads](../images/mapping/pairedend_read.png)]]

- **Mapping:** known distance between reads improves accuracy

  .center[.image-75[![Mapping of paired-end reads](../images/mapping/pairedend_mapping.png)]]

???

- The fragments are too long to sequence entirely, but we can sequence
the ends.
- Then we have the added information of how far apart these two reads must map
- This improves our mapping

- For example for multi-mapped reads, or repeats (next slide)

---

### Mate-pair Sequencing

- Just like paired-end sequencing
- Instead of 100-300 bases inbetween pairs, more like 1000-5000 bases

---

### Nanopore

- Very long reads but low quality
- Useful for resolving very large structural variation

![qc-nanopore](../images/quality-control/qc-nanopore.png)

---

# Formats

---

### Sequences: FASTA

```
>Identifier1 (comment)
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
>Identifier2 (comment)
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX
```

???

- familiar if you've seen genomic data before
- Starts with greater-than sign
- Then an identifier with no spaces
- Everything after a space is a comment
- Newline
- Everything up to next greater-than is sequence data (wrapping unnecessary)

Segue: But this is just sequence, and we have data from a sequencer, which includes quality

---

### Sequences: FASTQ

```
@Identifier1 (comment)
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
+
QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ
@Identifier2 (comment)
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
+
QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ
```

???

- Four lines
- @ + identifier on first line, just like fasta
- sequence
- +
- quality score characters

Segue: so what do the quality chars mean?

---

### Quality score

Measure of the quality of the identification of the nucleobases <br>generated by automated DNA sequencing

<small>

Phred Quality Score | Probability of incorrect base call | Base call accuracy
--- | --- | ---
10 | 1 in 10 | 90%
20 | 1 in 100 | 99%
30 | 1 in 1000 | 99.9%
40 | 1 in 10,000 | 99.99%
50 | 1 in 100,000 | 99.999%
60 | 1 in 1,000,000 | 99.9999%

</small>

???

- Logarithmic scale


---

# Working with Sequencing Data

---
class: top

## Paired-end FASTQ files

- Sequencer produces two FASTQ files:
  - **Forward** reads (usually **`_1`** or **`_R1`** in file name)
  - **Reverse** reads (usually **`_2`** or **`_R2`** in file name)


  ![Paired-end reads as two separate FASTQ files](../images/mapping/pairedend_fastq.png)


???
When you have paired-end data, you will usually get 2 files.
 - File names identical except for e.g. `_1`/`_2` or `_R1`/`_R2`
 - First file contains all the forward reads ("left" sides of pairs)
 - Other file contains all the reverse reads


Pairing also visible in read names
  - `/1` `/2` at end or `1:` and `2:` in read ID

--
- Sometimes: One **interleaved** (or **interlaced**) FASTQ file
  - Most tools require 2 separate files
  - {% icon tool %} De-interlace tools in Galaxy for conversion


???
Sometimes data can be in a single **interleaved file** (aka **interlaced**)
 - alternating forward and reverse read
 - de-interlace tools in Galaxy to convert this to two separate files
   - because many tools require two separate files


---
class: top

## Paired-end FASTQ files

- Order of reads matters!
  - **`N`<sup>th</sup>** read in forward file <i class="fa fa-arrows-h" aria-hidden="true"></i>
**`N`<sup>th</sup>** read in reverse file
  - Much faster than determining pairing by read names alone


- ***Always trim and filter together!***


???
Most tools blindly assume that first read in forward file is paired with first read in reverse file etc

Otherwise too slow
  - for every read, worst case have to scan all reads in other file
  - for files with millions of reads, that is millions ^ millions


When trimming and filtering, if a read is removed from one file, its mate must be removed from other one too!

**Always trim together in paired-end mode!**

--

.pull-left[
.red[
```
@PAIR-1 forward
GGGTGATGGCCGCTGCCGATGGCGTCAAAT
+
))%255CCF>>>>>>CCCCCCC65`IIII%
```
]
.orange[
```
@PAIR-2 forward
GATTTGGGGTTCAAAGCAGTATCGATCAA
+
!''3((((^^d+))%%%++)(%%%%).1)
```
]
.blue[
```
@PAIR-3 forward
TCGCACTCAACGCCCTGCATATGACAAGAC
+
A64;##=#B9=AAAAAAAAAA9#:AB95%^
```
]

**`mysample_R1.fastq`**
]

.pull-right[
<i class="fa fa-arrows-h" style="position:absolute;font-size:3em;left:6.4em;"></i>
.red[
```
@PAIR-1 reverse
AAGTTACCCTTAACAACTTAAGGGTTTTCA
+
fffddf`feedB`IABa)^%YBBBRTT\^d
```
]
<i class="fa fa-arrows-h" style="position:absolute;font-size:3em;left:6.4em;"></i>
.orange[
```
@PAIR-2 reverse
AGCAGAAGTCGATGATAATACGCGTCGTTT
+
IIIIIII^^IIId`?III%IIIGII>IIII
```
]<i class="fa fa-arrows-h" style="position:absolute;font-size:3em;left:6.4em;"></i>
.blue[
```
@PAIR-3 reverse
AATCCATTTGTTCAACTCACAGTTTACCGT
+
9C;=;=<9@4868>9:67AA<9>65<=>59
```
]
**`mysample_R2.fastq`**
]

???


- Nth read in forward file belongs in a pair with Nth read in reverse file
- So red reads in this slide form a pair, orange ones, etc


---
class: top

## Paired-end FASTQ files

- Order of reads matters!
  - **`N`<sup>th</sup>** read in forward file <i class="fa fa-arrows-h" aria-hidden="true"></i>
**`N`<sup>th</sup>** read in reverse file
  - Much faster than determining pairing by read names alone


- ***Always trim and filter together!***

.pull-left[
<i class="fa fa-arrows-h" style="position:absolute;font-size:3em;left:6.4em;"></i>
.red[
```
@PAIR-1 forward
GGGTGATGGCCGCTGCCGATGGCGTCAAAT
+
))%255CCF>>>>>>CCCCCCC65`IIII%
```
]
.left[<i class="fa fa-cut" style="width:15%;position:absolute;font-size:5em;"></i>]
<i class="fa fa-arrows-h" style="position:absolute;font-size:3em;left:6.4em;"></i>
.orange[
```
@PAIR-2 forward
GATTTGGGGTTCAAAGCAGTATCGATCAA
+
!''3((((^^d+))%%%++)(%%%%).1)
```
]
<i class="fa fa-arrows-h" style="position:absolute;font-size:3em;left:6.4em;"></i>
.blue[
```
@PAIR-3 forward
TCGCACTCAACGCCCTGCATATGACAAGAC
+
A64;##=#B9=AAAAAAAAAA9#:AB95%^
```
]

**`mysample_R1.fastq`**
]
.pull-right[
.red[
```
@PAIR-1 reverse
AAGTTACCCTTAACAACTTAAGGGTTTTCA
+
fffddf`feedB`IABa)^%YBBBRTT\^d
```
]
.orange[
```
@PAIR-2 reverse
AGCAGAAGTCGATGATAATACGCGTCGTTT
+
IIIIIII^^IIId`?III%IIIGII>IIII
```
]
.blue[
```
@PAIR-3 reverse
AATCCATTTGTTCAACTCACAGTTTACCGT
+
9C;=;=<9@4868>9:67AA<9>65<=>59
```
]
**`mysample_R2.fastq`**
]

???

- Important to always provide both files to trimming and filtering tools together
- If a read in one file gets removed (e.g. because it is below quality threshold), but it's mate is not, the pairing between the two files is no longer correct.

- If one half of pair is trimmed, the other
 - also removed, or
 - put into separate "singletons" FASTQ file that some mappers can use

- FAQ:" why not look at read names to determine pairing?"
  - analysis would be much slower if for every read must scan (max) entire other file for mate, since often millions or reads (for whole-genome sequencing).
---
class: top

## Paired-end FASTQ files

- Order of reads matters!
  - **`N`<sup>th</sup>** read in forward file <i class="fa fa-arrows-h" aria-hidden="true"></i>
**`N`<sup>th</sup>** read in reverse file
  - Much faster than determining pairing by read names alone


- ***Always trim and filter together!***

.pull-left[
<i class="fa fa-arrows-h" style="position:absolute;font-size:3em;left:6.4em;"></i>
.red[
```
@PAIR-1 forward
GGGTGATGGCCGCTGCCGATGGCGTCAAAT
+
))%255CCF>>>>>>CCCCCCC65`IIII%
```
]
<i class="fa fa-frown-o" style="position:absolute;font-size:3em;left:6.4em;"></i>
.blue[
```
@PAIR-3 forward
TCGCACTCAACGCCCTGCATATGACAAGAC
+
A64;##=#B9=AAAAAAAAAA9#:AB95%^
```
]
<i class="fa fa-frown-o" style="position:absolute;font-size:3em;left:6.4em;"></i>
.green[
```
@PAIR-4 forward
AAACTTCGTAGGTCCATTTGACAGCGTGCA
+
6664%!!III^(=%3333^^d^d:#32333
```
]
**`mysample_R1.fastq`**
]
.pull-right[
.red[
```
@PAIR-1 reverse
AAGTTACCCTTAACAACTTAAGGGTTTTCA
+
fffddf`feedB`IABa)^%YBBBRTT\^d
```
]
.orange[
```
@PAIR-2 reverse
AGCAGAAGTCGATGATAATACGCGTCGTTT
+
IIIIIII^^IIId`?III%IIIGII>IIII
```
]
.blue[
```
@PAIR-3 reverse
AATCCATTTGTTCAACTCACAGTTTACCGT
+
9C;=;=<9@4868>9:67AA<9>65<=>59
```
]
**`mysample_R2.fastq`**
]



???
By cutting the yellow read only from the forward reads file, but leaving the other side of pair in the other file, an incorrect pairing is now assumed by downstream tools


